<!doctype html>
<html>
	<head>
		<meta content="IE=edge" http-equiv="X-UA-Compatible">
		<meta charset="utf-8">
		<meta content="width=device-width,initial-scale=1.0" name="viewport">
		<meta name="theme-color" content="#000000">

		<title>Mandala</title>

		<link rel="stylesheet" href="/stylesheets/controls.css" type="text/css">

	</head>

	<body class="canvas canvas_mandala canvas_mandala_index">
		<main id="main">
	<canvas id="background"></canvas>
	<canvas id="canvas"></canvas>
</main>

<div class="controls">
	<p>
		<label for="sectors">Sectors</label>
		<input type="range" id="sectors" name="sectors"
			min="4" max="30" step="1" value="16">
		<output name="sectorsLabel" id="sectorsLabel">16</output>
	</p>
	<p>
		<label for="mirror">Mirror</label>
		<input type="checkbox" id="mirror" name="mirror" checked>
	</p>
	<p>
		<labek for="color">Color</labek>
		<input type="color" id="color" name="color" value="#ffffff">
	</p>
	<p>
		<label for="clear">Clear canvas</label>
		<button id="clear" name="clear">Clear</button>
	</p>
</div>

<script type="text/javascript">
'use strict'

var main = document.getElementById('main'),
	canvas = document.getElementById('canvas'),
	ctx = canvas.getContext('2d'),
	background = document.getElementById('background'),
	bgctx = background.getContext('2d')

var width = 600 < window.innerWidth ? 600 : window.innerWidth
	canvas.width = canvas.height = background.width = background.height = width

var ratio = window.devicePixelRatio
ctx.scale(ratio, ratio)

var opts = {
	sectors: 16,
	angle: (360 / 16) * (Math.PI / 180),
	mirror: true,
	color: '#ffffff'
}

var points = []
var startingX
var startingY

var centerX = canvas.width / 2
var centerY = canvas.height / 2

function changeSectors(event) {
	if (event) {
		opts.sectors = parseFloat(event.target.value)
	}
	opts.angle = (360 / opts.sectors) * (Math.PI / 180)

	bgctx.save()
	bgctx.fillStyle = 'black'
	bgctx.fillRect(0, 0, canvas.width, canvas.height)
	bgctx.lineWidth = 1
	for (var i = 0; i < opts.sectors; i++) {
		bgctx.translate(canvas.width/2, canvas.height/2)
		bgctx.rotate(opts.angle)
		bgctx.translate(-canvas.width/2, -canvas.height/2)

		bgctx.beginPath()
		bgctx.moveTo(canvas.width/2, canvas.height/2)
		bgctx.lineTo(canvas.width, canvas.height)
		bgctx.strokeStyle = "#333"
		bgctx.stroke()
	}
	bgctx.restore()
	sectorsLabel.value = opts.sectors
}

changeSectors()

function hexToRgb(hex) {
	var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex)
	return `rgba(${parseInt(result[1], 16)}, ${parseInt(result[2], 16)}, ${parseInt(result[3], 16)}, 0.1)`
}

function draw() {
	ctx.lineWidth = 0
	ctx.lineJoin = ctx.lineCap = 'round'
	ctx.strokeStyle = hexToRgb(opts.color)
	ctx.shadowBlur = 0.5
	ctx.shadowColor = opts.color

	for (var i = 0; i < opts.sectors; i++) {
		// rotate
		ctx.translate(canvas.width/2, canvas.height/2)
		ctx.rotate(opts.angle)
		ctx.translate(-canvas.width/2, -canvas.height/2)

		for (var j = 1; j < points.length; j++) {
			ctx.beginPath()
			ctx.moveTo(points[j - 1].x, points[j - 1].y)
			ctx.lineTo(points[j].x, points[j].y)
			ctx.stroke()
		}
	}

	if (opts.mirror) {
		for (var i = 0; i < opts.sectors; i++) {
			// rotate
			ctx.translate(canvas.width/2, canvas.height/2)
			ctx.rotate(opts.angle)
			ctx.translate(-canvas.width/2, -canvas.height/2)

			for (var j = 1; j < points.length; j++) {
				var x1 = Math.abs(points[j - 1].x - canvas.width),
					x2 = Math.abs(points[j].x - canvas.width)

				ctx.beginPath()
				ctx.moveTo(x1, points[j - 1].y)
				ctx.lineTo(x2, points[j].y)
				ctx.stroke()
			}
		}
	}
}

canvas.addEventListener('mousedown', function(event) {
	var x = event.clientX - main.offsetLeft
	var y = event.clientY - main.offsetTop

	this.drawing = true
	startingX = x
	startingY = y
})

canvas.addEventListener('mousemove', function(event) {
	var x = event.clientX - main.offsetLeft
	var y = event.clientY - main.offsetTop

	if (this.drawing) {
		points.push({
			x: x,
			y: y
		})
		draw()
	}
})

document.addEventListener('mouseup', function(event) {
	canvas.drawing = false
	points = []
})

document.getElementById('mirror').addEventListener('change', function(event) {
	if (this.checked) {
		opts.mirror = true
	} else {
		opts.mirror = false
	}
})

document.getElementById('color').addEventListener('change', function(event) {
	opts.color = this.value
})

document.getElementById('sectors').addEventListener('change', changeSectors)

document.getElementById('clear').addEventListener('click', function(){
	ctx.clearRect(0, 0, canvas.width, canvas.height)
})

window.addEventListener('resize', function(event) {
	var oldWidth = canvas.width
	var newWidth = window.innerWidth
	if (newWidth < 600) {
		canvas.width = canvas.height = background.width = background.height = newWidth
		changeSectors()
	} else if (oldWidth !== 600) {
		canvas.width = canvas.height = background.width = background.height = 600
		changeSectors()
	}
})

</script>
</body>

	</body>
</html>
